
classdef ReplayMeasuramentsCtSystem < CtSystem & InitDeinitObject

 
    properties
    
    timeLog
    measurementLog
    end
    
    methods
        
        
        function obj = ReplayMeasuramentsCtSystem (varargin)
            
            obj = obj@CtSystem(varargin{:});
            
            %% Retrive parameters for superclass GeneralSystem
            
            parameterPointer = 1;
            
            hasParameters = length(varargin)-parameterPointer>=0;
            
            while hasParameters
                
                if (ischar(varargin{parameterPointer}))
                    
                    switch varargin{parameterPointer}
                        
                        case 'TimeLog'
                            
                            obj.timeLog = varargin{parameterPointer+1};
                            
                            parameterPointer = parameterPointer+2;
                            
                        case 'MeasurementLog'
                            
                            obj.measurementLog = varargin{parameterPointer+1};
                            
                            parameterPointer = parameterPointer+2;
                            
                        otherwise
                            
                            parameterPointer = parameterPointer+1;
                            
                    end
                else
                    parameterPointer = parameterPointer+1;
                end
                
                hasParameters = length(varargin)-parameterPointer>=0;
                
            end
            
            if isempty(obj.timeLog) || isempty(obj.measurementLog)
                
                error(getMessage('ReplaySys:missingLos'));
                
            end
            
            %% Ask initial Condition
            if isempty(obj.nx)
                obj.nx=1;
            end
           
            if isempty(obj.ny)
                obj.ny=size(obj.measurementLog,1);
            end
            
            obj.initialConditions = zeros(obj.nx,1);
            
            obj.f = @(t,x,u)zeros(obj.nx,1);
            obj.h = @(t,x)obj.readMeasurementLog(t);
            
            
        end
        
        function fakeDotX = sendCommand(obj,t,u)
            
            if ~isempty(obj.dt) && mod(round(t/obj.dt),obj.downsampleSendCommand)~=0
                fakeDotX = zeros(obj.nx,1);
            else
                tid = tic;
                channels = obj.u2channels(u);
                disp(channels);
                obj.send(channels);
                
                fakeDotX = zeros(obj.nx,1);
                obj.lastSendTime = toc(tid);
            end
            
        end
        
        function y = readMeasurementLog(obj,t)
            
            indexesMeasuremen = find(obj.timeLog>t);
            
            %if mod(round(t/obj.dt),1)==0
            %    fprintf('read %d\n',t);
            tid = tic;
            %data = [posMarker1;posMarker2;posMarker3]
            data = obj.recieve();
            
            [p,theta] = obj.markers2ptheta(data(1:2),data(4:5),data(7:8));
            if obj.ny ==2
                y = p;
            else
                y = [p;theta];
            end
            
            obj.lastReadTime = toc(tid);

        end
        
        function closeConnection(obj)
            
            fclose(obj.udpObj);
            delete(obj.udpObj);
            PCTx('close');
            disp('Connection Closed')
            
        end
        
        function send(obj,channels)
            
            if PCTx('send',channels) == -1
                obj.closeConnection();
                error('Communcation Error')
            end
            
        end
        
        function data = recieve(obj)
            
            try
                
                %Flush the buffer to get the most updated measurament
                %TODO: check delay
                flushinput(obj.udpObj);
                
                if obj.commProtocol == 1 % Send on request
                    fwrite(obj.udpObj, 1, 'double');
                end
                
                waitingTime = 0;
                
                
                
                tic
                
                while not(obj.udpObj.BytesAvailable) && waitingTime<=obj.maxWaitingTime
                    
                    waitingTime = toc;
                    
                end
                
                if waitingTime>obj.maxWaitingTime
                    fclose(obj.udpObj);
                    delete(obj.udpObj);
                    error(sprintf('Timeout (maxWaitingTime:%d)',obj.maxWaitingTime));
                end
                
                data = fread(obj.udpObj, obj.udpObj.BytesAvailable,'double');
                
            catch e
                
                obj.closeConnection();
                
            end
            
            
        end
        
        function init(obj)
            
            obj.udpObj = udp(...
                obj.remoteIp, obj.remotePort, ...
                'LocalPort'        , obj.localPort,...
                'timeout'          , 30           ,...
                'OutputBufferSize' , 2048         ,...
                'InputBufferSize'  , 2048         );
            
            fopen(obj.udpObj);
            obj.cleanUpObj = onCleanup(@() obj.closeConnection());
            
            if PCTx('open')==0
                error('Error connecting to PCTx');
            end
            
            % Run closeConnection in case of termination by the user
            
            
        end
        
        function initSimulation(obj)
            
            if obj.startingCommand
                
                system(obj.startingCommand);
                pause(obj.waitAfterStartingCommand);
                
            end
            
            obj.init();
            disp('Connection open')
        end
        
        function deinitSimulation(obj)
            
            fwrite(obj.udpObj,'CLOSE','char');
            obj.closeConnection();
            
        end
        
        
        
        function u = v2uMap(obj,v)
            vMax = obj.vMax;
            vMin = obj.vMin;
            v = min(vMax,max(v,vMin));
            
            if v>eps && v<1
                k1 =0.3;
                k2 = 1/vMax;
                k3 = 0.7;%0.65;
                
                u = k1*tan(k2*(pi/2)*v)+ k3;
            else
                k1 = 0.5;
                k2 = 0.84-k1;
                u = k1*v + k2;
            end
            
        end
        
        function channels = u2channels(obj,u)
            
            u(1) = obj.v2uMap(u(1))/1.320;
            
            chMax    = obj.chMax;
            channels = zeros(1,10);
            
            %angle
            deltaMax = 0.3456; %rad
            delta = u(2);
            
            chThetaMax = obj.chThetaMax;
            chThetaMin = obj.chThetaMin;
            if delta<0
                delta = delta*1.2;
            end
            
            delta = delta*1.2;
             
            chDelta = (delta/deltaMax)*200+(chThetaMin+chThetaMax)/2-50;
            
            chDelta = min(max(obj.chThetaMin,chDelta),obj.chThetaMax);
            
            %velocity
            vaMax = 1.5;%m/sec
            vaMin = -vaMax;
            v     = min(max(vaMin,u(1)),vaMax);
            chV   = (v/vaMax)*80+600;
            
            
            channels(1)=chV;
            channels(2)=chDelta;
            
        end
        
        function [p,theta] = markers2ptheta(obj,pm1,pm2,pm3)
            pts = [pm1,pm2,pm3];
            d=zeros(3,1);
            d(1) = norm(pts(:,1)-pts(:,2));
            d(2) = norm(pts(:,2)-pts(:,3));
            d(3) = norm(pts(:,3)-pts(:,1));
            
            dBackMarkers = find(d==min(d));
            
            m3 = dBackMarkers-1; %frontMarcker
            if m3==0
                m3=3;
            end
            
            backMarckers = find([1,2,3]~=m3);
            
            d1 = norm(pts(:,m3)-pts(:,backMarckers(1)));
            d2 = norm(pts(:,m3)-pts(:,backMarckers(2)));
            m2 = backMarckers(logical([d1,d2]==min([d1,d2])));
            m1 = backMarckers(logical([d1,d2]~=min([d1,d2])));
            pm1 = pts(:,m1);
            pm2 = pts(:,m2);
            pm3 = pts(:,m3);
            
                    correction =  2.8235;%-2.9287;%;% 2.5947;%-2.65 
                    vHeading = pm2-(pm1+pm3)*0.5;
                    theta    = atan2(vHeading(2),vHeading(1))+correction;
                    p        = (1/3)*(pm1+pm2+pm3)*0.001;
            
            
        end
    end
    
    methods (Static)
        
        
        
        
        
        
    end
    
end